# Component Architecture Document

## Overview

This document defines the component architecture for Gebeta, establishing a systematic approach to component design, organization, and implementation. The architecture ensures consistency, maintainability, and scalability across all UI components.

---

## Component Organization

### Directory Structure

```
src/
├── components/
│   ├── ui/                    # Base/primitive components
│   │   ├── Button/
│   │   │   ├── Button.tsx
│   │   │   ├── Button.stories.tsx
│   │   │   ├── Button.test.tsx
│   │   │   └── index.ts
│   │   ├── Input/
│   │   ├── Card/
│   │   ├── Modal/
│   │   ├── Toast/
│   │   └── ...
│   ├── layout/               # Layout components
│   │   ├── Container/
│   │   ├── Grid/
│   │   ├── Sidebar/
│   │   ├── Header/
│   │   └── Footer/
│   ├── features/             # Feature-specific components
│   │   ├── menu/
│   │   │   ├── MenuItemCard/
│   │   │   ├── MenuCategoryList/
│   │   │   └── MenuEditor/
│   │   ├── analytics/
│   │   │   ├── MetricCard/
│   │   │   ├── ChartCard/
│   │   │   └── DashboardGrid/
│   │   ├── qr/
│   │   │   ├── QRCodeGenerator/
│   │   │   └── QRCodeDisplay/
│   │   └── upselling/
│   │       ├── UpsellingRuleCard/
│   │       └── UpsellingAnalytics/
│   ├── forms/                # Form components
│   │   ├── MenuItemForm/
│   │   ├── CategoryForm/
│   │   └── SettingsForm/
│   └── hooks/                # Custom hooks
│       ├── useMenuItems/
│       ├── useAnalytics/
│       └── useQRCode/
├── utils/                    # Utility functions
├── types/                    # TypeScript types
└── styles/                   # Global styles
```

### Component Categories

#### 1. UI Components (Primitive)

**Characteristics:**
- Foundation-level components
- No business logic
- Highly reusable
- Styled using design tokens

**Examples:**
- Button, Input, Card, Modal, Toast, Alert, Badge, Avatar, Dropdown

#### 2. Layout Components

**Characteristics:**
- Structure the application
- Handle responsive behavior
- Manage navigation
- Handle spacing and positioning

**Examples:**
- Container, Grid, Sidebar, Header, Footer, PageLayout, ModalLayout

#### 3. Feature Components

**Characteristics:**
- Domain-specific functionality
- Composed of UI components
- May include business logic
- Connected to state management

**Examples:**
- MenuItemCard, MenuCategoryList, MetricCard, QRCodeGenerator

#### 4. Form Components

**Characteristics:**
- Handle form logic
- Include validation
- Manage form state
- Connected to data layer

**Examples:**
- MenuItemForm, CategoryForm, SettingsForm, RestaurantForm

---

## Component Design Principles

### 1. Composition Over Inheritance

**Pattern:** Build complex components from simple ones

```tsx
// Good: Composition
function MenuCard({ item, onEdit, onDelete }) {
  return (
    <Card hover>
      <CardImage src={item.imageUrl} alt={item.name} />
      <CardContent>
        <CardTitle>{item.name}</CardTitle>
        <CardDescription>{item.description}</CardDescription>
        <CardFooter>
          <span className="price">{formatCurrency(item.price)}</span>
          <ButtonGroup>
            <Button size="sm" variant="ghost" onClick={() => onEdit(item)}>
              <EditIcon />
            </Button>
            <Button size="sm" variant="ghost" onClick={() => onDelete(item)}>
              <DeleteIcon />
            </Button>
          </ButtonGroup>
        </CardFooter>
      </CardContent>
    </Card>
  );
}
```

### 2. Single Responsibility

**Pattern:** Each component does one thing well

```tsx
// Good: Single responsibility
function PriceDisplay({ price, currency }) {
  return <span>{formatCurrency(price, currency)}</span>;
}

function MenuItemName({ name, description }) {
  return (
    <div>
      <h3>{name}</h3>
      <p>{description}</p>
    </div>
  );
}

function MenuItemActions({ onEdit, onDelete }) {
  return (
    <ButtonGroup>
      <Button onClick={onEdit}>Edit</Button>
      <Button onClick={onDelete} variant="destructive">Delete</Button>
    </ButtonGroup>
  );
}
```

### 3. Controlled Components

**Pattern:** Component state is controlled by parent

```tsx
// Good: Controlled component
function Input({ value, onChange, error }) {
  return (
    <input
      value={value}
      onChange={(e) => onChange(e.target.value)}
      className={error ? 'error' : ''}
    />
  );
}

// Bad: Uncontrolled component with internal state
function Input({ error }) {
  const [value, setValue] = useState('');
  // ...
}
```

### 4. Hooks for Logic

**Pattern:** Extract complex logic into custom hooks

```tsx
// Good: Custom hook for complex logic
function useMenuItems(restaurantId) {
  const [items, setItems] = useState([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);

  useEffect(() => {
    fetchMenuItems(restaurantId)
      .then(setItems)
      .catch(setError)
      .finally(() => setLoading(false));
  }, [restaurantId]);

  return { items, loading, error, refetch: () => {...} };
}
```

---

## Component Interface Design

### Props Interface

```tsx
// TypeScript interface for component props
interface ButtonProps {
  // Required props
  children: React.ReactNode;
  
  // Optional props with defaults
  variant?: 'primary' | 'secondary' | 'ghost' | 'destructive';
  size?: 'sm' | 'md' | 'lg';
  disabled?: boolean;
  loading?: boolean;
  
  // Event handlers
  onClick?: () => void;
  
  // Conditional props
  icon?: React.ReactNode;
  iconPosition?: 'left' | 'right';
  
  // Style overrides
  className?: string;
  style?: React.CSSProperties;
}
```

### Default Props

```tsx
Button.defaultProps = {
  variant: 'primary',
  size: 'md',
  disabled: false,
  loading: false,
  iconPosition: 'left',
};
```

### Generic Components

```tsx
// Generic list component
interface ListProps<T> {
  items: T[];
  renderItem: (item: T, index: number) => React.ReactNode;
  keyExtractor: (item: T) => string;
  emptyMessage?: string;
  loading?: boolean;
}

function List<T>({ items, renderItem, keyExtractor, emptyMessage }: ListProps<T>) {
  if (items.length === 0) {
    return <EmptyState message={emptyMessage} />;
  }

  return (
    <ul>
      {items.map((item, index) => (
        <li key={keyExtractor(item)}>
          {renderItem(item, index)}
        </li>
      ))}
    </ul>
  );
}
```

---

## State Management

### Component State

```tsx
// Local component state
function Counter() {
  const [count, setCount] = useState(0);
  
  return (
    <Button onClick={() => setCount(count + 1)}>
      Count: {count}
    </Button>
  );
}
```

### Context State

```tsx
// Global app state with Context
interface AppContextType {
  user: User | null;
  restaurant: Restaurant | null;
  isLoading: boolean;
  signIn: (email: string, password: string) => Promise<void>;
  signOut: () => Promise<void>;
}

const AppContext = createContext<AppContextType | null>(null);

export function AppProvider({ children }) {
  const [user, setUser] = useState<User | null>(null);
  // ...
  
  return (
    <AppContext.Provider value={{ user, restaurant, isLoading, signIn, signOut }}>
      {children}
    </AppContext.Provider>
  );
}
```

### Server State

```tsx
// React Query for server state
function useMenuItems(restaurantId: string) {
  return useQuery({
    queryKey: ['menuItems', restaurantId],
    queryFn: () => fetchMenuItems(restaurantId),
    staleTime: 5 * 60 * 1000, // 5 minutes
  });
}

function useUpdateMenuItem() {
  const queryClient = useQueryClient();
  
  return useMutation({
    mutationFn: (item: MenuItem) => updateMenuItem(item),
    onSuccess: () => {
      queryClient.invalidateQueries(['menuItems']);
    },
  });
}
```

---

## Component Testing Strategy

### Unit Tests

```tsx
// Button.test.tsx
import { render, screen, fireEvent } from '@testing-library/react';
import { Button } from './Button';

describe('Button', () => {
  it('renders children correctly', () => {
    render(<Button>Click me</Button>);
    expect(screen.getByRole('button')).toHaveTextContent('Click me');
  });

  it('calls onClick when clicked', () => {
    const handleClick = jest.fn();
    render(<Button onClick={handleClick}>Click me</Button>);
    fireEvent.click(screen.getByRole('button'));
    expect(handleClick).toHaveBeenCalledTimes(1);
  });

  it('is disabled when loading', () => {
    render(<Button loading>Click me</Button>);
    expect(screen.getByRole('button')).toBeDisabled();
  });

  it('shows loading text when loading', () => {
    render(<Button loading>Click me</Button>);
    expect(screen.getByRole('button')).toHaveTextContent('Loading...');
  });
});
```

### Integration Tests

```tsx
// MenuEditor.test.tsx
import { render, screen, fireEvent } from '@testing-library/react';
import { MenuEditor } from './MenuEditor';
import { useMenuItems } from '../../hooks/useMenuItems';

jest.mock('../../hooks/useMenuItems');

describe('MenuEditor', () => {
  it('displays list of menu items', () => {
    useMenuItems.mockReturnValue({
      items: [
        { id: '1', name: 'Burger', price: 9.99 },
        { id: '2', name: 'Pizza', price: 12.99 },
      ],
      loading: false,
    });

    render(<MenuEditor restaurantId="123" />);
    expect(screen.getByText('Burger')).toBeInTheDocument();
    expect(screen.getByText('Pizza')).toBeInTheDocument();
  });

  it('opens add item modal when button clicked', () => {
    render(<MenuEditor restaurantId="123" />);
    fireEvent.click(screen.getByText('Add Item'));
    expect(screen.getByRole('dialog')).toBeInTheDocument();
  });
});
```

### Snapshot Tests

```tsx
// Card.test.tsx
import { render } from '@testing-library/react';
import { Card } from './Card';

describe('Card', () => {
  it('matches snapshot', () => {
    const { container } = render(
      <Card>
        <CardContent>Card content</CardContent>
      </Card>
    );
    expect(container).toMatchSnapshot();
  });
});
```

---

## Component Documentation

### Storybook Stories

```tsx
// Button.stories.tsx
import type { Meta, StoryObj } from '@storybook/react';
import { Button } from './Button';

const meta: Meta<typeof Button> = {
  title: 'UI/Button',
  component: Button,
  parameters: {
    layout: 'centered',
  },
  tags: ['autodocs'],
  argTypes: {
    variant: {
      control: { type: 'select' },
      options: ['primary', 'secondary', 'ghost', 'destructive'],
    },
    size: {
      control: { type: 'select' },
      options: ['sm', 'md', 'lg'],
    },
  },
};

export default meta;
type Story = StoryObj<typeof Button>;

export const Primary: Story = {
  args: {
    children: 'Primary Button',
    variant: 'primary',
  },
};

export const Secondary: Story = {
  args: {
    children: 'Secondary Button',
    variant: 'secondary',
  },
};

export const Loading: Story = {
  args: {
    children: 'Loading...',
    loading: true,
  },
};

export const Disabled: Story = {
  args: {
    children: 'Disabled Button',
    disabled: true,
  },
};
```

### Component Documentation Template

```tsx
/**
 * Button Component
 * 
 * ## Overview
 * A versatile button component that supports multiple variants, sizes, and states.
 * 
 * ## Usage
 * ```tsx
 * <Button variant="primary" onClick={handleClick}>
 *   Click me
 * </Button>
 * ```
 * 
 * ## Props
 * 
 * | Prop | Type | Default | Description |
 * |------|------|---------|-------------|
 * | children | ReactNode | - | Button content |
 * | variant | 'primary' | 'secondary' | 'ghost' | 'destructive' | 'primary' | Visual style variant |
 * | size | 'sm' | 'md' | 'lg' | 'md' | Button size |
 * | disabled | boolean | false | Whether button is disabled |
 * | loading | boolean | false | Shows loading state |
 * | onClick | () => void | - | Click handler |
 * 
 * ## Examples
 * 
 * ### Primary Button
 * <Button variant="primary">Primary</Button>
 * 
 * ### Secondary Button
 * <Button variant="secondary">Secondary</Button>
 * 
 * ### With Icon
 * <Button icon={<PlusIcon />} iconPosition="right">
 *   Add Item
 * </Button>
 */
```

---

## Performance Optimization

### Code Splitting

```tsx
// Lazy load heavy components
const MenuEditor = lazy(() => import('./features/menu/MenuEditor'));
const AnalyticsDashboard = lazy(() => import('./features/analytics/AnalyticsDashboard'));

function App() {
  return (
    <Suspense fallback={<Loading />}>
      <Routes>
        <Route path="/menu" element={<MenuEditor />} />
        <Route path="/analytics" element={<AnalyticsDashboard />} />
      </Routes>
    </Suspense>
  );
}
```

### Memoization

```tsx
// Memoize expensive components
const ExpensiveComponent = memo(function ExpensiveComponent({ data }) {
  // Expensive computation
  return <div>{processedData}</div>;
});

// Memoize callback functions
const handleClick = useCallback(() => {
  // Callback logic
}, [dependency]);
```

### Virtual Lists

```tsx
// Virtual list for large datasets
import { FixedSizeList as List } from 'react-window';

function MenuItemList({ items }) {
  return (
    <List
      height={400}
      itemCount={items.length}
      itemSize={80}
      width="100%"
    >
      {({ index, style }) => (
        <div style={style}>
          <MenuItem item={items[index]} />
        </div>
      )}
    </List>
  );
}
```

---

## Accessibility Implementation

### ARIA Attributes

```tsx
// Accessible button with ARIA
<Button
  aria-label="Add new menu item"
  aria-describedby="add-item-help"
  aria-expanded={isExpanded}
  aria-controls="menu-items-list"
>
  <PlusIcon />
  <span className="sr-only" id="add-item-help">
    Click to add a new item to your menu
  </span>
</Button>
```

### Focus Management

```tsx
// Manage focus for modal
function Modal({ isOpen, onClose, children }) {
  const focusRef = useRef(null);

  useEffect(() => {
    if (isOpen) {
      focusRef.current?.focus();
    }
  }, [isOpen]);

  const handleKeyDown = (e: React.KeyboardEvent) => {
    if (e.key === 'Escape') {
      onClose();
    }
    if (e.key === 'Tab') {
      // Trap focus within modal
    }
  };

  if (!isOpen) return null;

  return (
    <div
      role="dialog"
      aria-modal="true"
      aria-labelledby="modal-title"
      onKeyDown={handleKeyDown}
    >
      <div ref={focusRef} tabIndex={-1}>
        {children}
      </div>
    </div>
  );
}
```

---

## Component Migration Strategy

### Legacy Component Wrapper

```tsx
// Wrapper for legacy components
export function LegacyButton({ variant, children, ...props }) {
  // Map old variants to new ones
  const newVariant = variant === 'default' ? 'primary' : variant;
  
  return (
    <Button variant={newVariant} {...props}>
      {children}
    </Button>
  );
}
```

### Incremental Migration

1. Create new component alongside legacy
2. Use new component for new features
3. Gradually migrate existing usage
4. Remove legacy component when fully migrated

---

## Document Metadata

- **Created:** 2025-02-04
- **Author:** SDLC Orchestrator
- **Phase:** Phase 2 - Architecture & Planning
- **Skill:** Component Architecture (skill 7)
- **Status:** ✅ Complete
- **Next Skill:** Motion Interactions (skill 8)